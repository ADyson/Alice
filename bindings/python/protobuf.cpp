/**
 * @file protobuf.cpp
 * @author Robin Dietrich <me (at) invokr (dot) org>
 * @version 1.0
 *
 * @par License
 *    Alice Replay Parser
 *    Copyright 2014 Robin Dietrich
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

#include <string>
#include <iostream>
#include <algorithm>
#include <map>

#include <google/protobuf/compiler/command_line_interface.h>
#include <google/protobuf/compiler/code_generator.h>

#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <google/protobuf/wire_format.h>
#include <google/protobuf/descriptor.pb.h>

using namespace google::protobuf;
using namespace google::protobuf::compiler;

/** Print file header */
void PrintHeader(const FileDescriptor* file, io::Printer& p) {
    std::string headername = file->name().substr(0, file->name().size()-6);

    p.Print(
        "// Generated by the protocol buffer compiler. DO NOT EDIT!\n"
        "// Source: $filename$\n"
        "\n"
        "#ifndef PROTOBUF_$filename$_BOOST_PYTHON_INCLUDED\n"
        "#define PROTOBUF_$filename$_BOOST_PYTHON_INCLUDED\n"
        "\n",
        "filename", headername
    );
}

/** Print file footer */
void PrintFooter(const FileDescriptor* file, io::Printer& p) {
    std::string headername = file->name().substr(0, file->name().size()-5);
    headername.append(".pb.h");

    p.Print(
        "#endif // PROTOBUF_$filename$_BOOST_PYTHON_INCLUDED\n",
        "filename", file->name()
    );
}

/** Generate output for an enum */
void GenEnum(const EnumDescriptor* descriptor) {

}

/** Generate output for a single messages */
void GenMessage(const Descriptor* descriptor, io::Printer& p, std::string subname = "") {
    // scope the class name to prevent clashes
    std::string cls;
    if (!subname.empty())
        cls = subname+"_"+descriptor->name();
    else
        cls = descriptor->name();

    // Generate sub messages
    for (int32_t i = 0; i < descriptor->nested_type_count(); i++) {
        GenMessage(descriptor->nested_type(i), p, cls);
    }

    // Generate sub enums
    for (int32_t i = 0; i < descriptor->enum_type_count(); i++) {
        GenEnum(descriptor->enum_type(i));
    }

    // Generate iterators for repeated fields
    /*for (int32_t i = 0; i < descriptor->field_count(); ++i) {
        const FieldDescriptor* field = descriptor->field(i);

        std::map<std::string, std::string> vars;
        vars["name"] = field->name();
        vars["class"] = cls;

        std::string& name = vars["name"];
        std::transform(name.begin(), name.end(), name.begin(), ::tolower);

        if (field->is_repeated()) {
            // Prints iterator for field
            p.Print(
                vars,
                "template <typename T>\n"
                "class $class$_$name$_iterator {\n"
                "   public:\n"
                "       static get(T& msg) {\n"
                "           return $class$_$name$_iterator(msg);\n"
                "       }\n\n"

                "       $class$_$name$_iterator(T& msg) : m(msg) {}\n\n"

                "       T& next() {\n"
                "           if(index == 100) {\n"
                "               PyErr_SetObject(PyExc_StopIteration, Py_None);\n"
                "               throw_error_already_set();\n"
                "           }\n"
                "           return msg.mutable_$name$(index++);\n"
                "       }\n"
                "   private:\n"
                "       T& m;\n"
                "       uint32_t index;\n"
                "};\n\n"
            );
        }
    }*/

    // Class name
    p.Print(
        "class_<$class$>(\"$class$\")\n",
        "class", cls,
        "name", descriptor->name()
    );

    // Fields
    for (int32_t i = 0; i < descriptor->field_count(); ++i) {
        const FieldDescriptor* field = descriptor->field(i);

        std::map<std::string, std::string> vars;
        vars["name"] = field->name();
        vars["class"] = cls;

        std::string& name = vars["name"];
        std::transform(name.begin(), name.end(), name.begin(), ::tolower);

        if (field->is_repeated()) {
            p.Print(vars, "\t.def(\"$name$_size\", &$class$::$name$_size)\n");
            //p.Print(vars, "\t.def(\"$name$\", &$class$::$name$)\n");
        } else {
            p.Print(vars, "\t.def(\"has_$name$\", &$class$::has_$name$)\n");

            switch (field->type()) {
                case FieldDescriptor::TYPE_BYTES:
                case FieldDescriptor::TYPE_MESSAGE:
                    p.Print(vars, "\t.def(\"$name$\", &$class$::$name$, return_value_policy<reference_existing_object>())\n");
                    break;
                case FieldDescriptor::TYPE_STRING:
                    p.Print(vars, "\t.def(\"$name$\", &$class$::$name$, return_value_policy<copy_const_reference>())\n");
                    break;
                default:
                    p.Print(vars, "\t.def(\"$name$\", &$class$::$name$)\n");
            }
        }

        p.Print(vars, "\t.def(\"clear_$name$\", &$class$::clear_$name$)\n");
    }

    // Final semicolon, new line
    p.Print(";\n\n");
}

/** Generates a boost.python cpp from a protocol definition */
class BoostPythonGenerator : public CodeGenerator {
    public:
        /** Empty constructor */
        BoostPythonGenerator() {};
        /** Empty destructor */
        ~BoostPythonGenerator() {};

        /** Implements the code generator */
        bool Generate(
            const FileDescriptor* file, const string& parameter, GeneratorContext* generator_context, string* error
        ) const {
            // Basename for output
            std::string basename = file->name().substr(0, file->name().size()-5);

            // Get output stream
            scoped_ptr<io::ZeroCopyOutputStream> output(generator_context->Open(basename + "python.hpp"));
            io::Printer printer(output.get(), '$');

            // Print header
            PrintHeader(file, printer);

            // Parse messages
            for (int32_t i = 0; i < file->message_type_count(); ++i) {
                GenMessage(file->message_type(i), printer);
            }

            // Parse enums
            for (int32_t i = 0; i < file->enum_type_count(); i++) {
                GenEnum(file->enum_type(i));
            }

            // Print footer
            PrintFooter(file, printer);

            return true;
        }
};

/** Main method invoking the generator */
int main(int argc, char** argv) {
    google::protobuf::compiler::CommandLineInterface cli;

    BoostPythonGenerator bpgen;
    cli.RegisterGenerator("--bp_out", &bpgen, "Generate bindings using boost.python.");

    return cli.Run(argc, argv);
}